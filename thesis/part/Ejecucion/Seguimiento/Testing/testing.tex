Esta sección muestra la aplicación de los principios descritos en el apartado~\nameref{par:testing} en los casos más didácticos y relevantes.
El primer caso relevante es el proceso de diseño de los tests para~\nameref{subsubsec:CreateTaskUseCase}.
Primero se identifican los factores o variables independientes:

\begin{itemize}
    \item Host
    \item Port
    \item CommunicationMode
    \item ExecutionMode
    \item Steps
\end{itemize}

luego se extraen las clases de equivalencia:

\begin{itemize}
    \item Host: valid/invalid
    \item Port: valid/invalid
    \item CommunicationMode: valid/invalid
    \item ExecutionMode: valid/invalid
    \item Steps: valid/invalid
\end{itemize}

En este caso no aplica el criterio de valores límite.
Hay que prestar atención al trabajo de buscar las clases de equivalencia, no es trivial.
Por ejemplo, en el caso de steps, que es un array podría pensarse que se necesita probar varios elementos en el array, validos e inválidos, pero no tiene sentido porque la lógica debe contemplar únicamente el caso de uso.
Es tarea de la clase Step verificar este tipo de lógicas.
Otro ejemplo en el caso de Host o Port que tiene validaciones.
podría pensarse que debería ponerse a prueba con varios casos que sean inválidos, al ser un string libre, y que ponga a prueba dicha validación;
eso será responsabilidad del test unitario de Host y Port.
El diseño debe ceñirse a la lógica del caso de uso.
En un ejemplo tan trivial puede llevar a subestimar el ejercicio de entender el alcance de la prueba y la correcta selección de las clases de equivalencia, pero es de suma importancia.

Con estas clases de equivalencia las posibilidades son $2^5 = 32$.
Aplicando el método pairwise de~\nameref{variablesDependendientes} y se reducen a 6 los tests.
Los pares posibles son 41.
las combinaciones posibles se aprecian en la~\cref{tab:pairsCreateTaskUseCase} y los pares en la~\cref{tab:combCreateTaskUseCase}.
Los test a implementar finalmente se pueden ver en la~\cref{tab:createTaskPairWiseTest}

\begin{table}[H]
    \caption{Pares en el diseño de tests para CreateTaskUseCase.}\label{tab:pairsCreateTaskUseCase}
    \small
    \begin{tabular}{cccccc}
        \textbf{}   & \textbf{host} & \textbf{port} & \textbf{communicationMode} & \textbf{executionMode} & \textbf{sentences} \\
        \hline
        \textbf{1}  & valid         & valid         & valid                      & valid                  & valid              \\
        \hline
        \textbf{2}  & valid         & valid         & valid                      & valid                  & invalid            \\
        \hline
        \textbf{3}  & valid         & valid         & valid                      & invalid                & valid              \\
        \hline
        \textbf{4}  & valid         & valid         & valid                      & invalid                & invalid            \\
        \hline
        \textbf{5}  & valid         & valid         & invalid                    & valid                  & valid              \\
        \hline
        \textbf{6}  & valid         & valid         & invalid                    & valid                  & invalid            \\
        \hline
        \textbf{7}  & valid         & valid         & invalid                    & invalid                & valid              \\
        \hline
        \textbf{8}  & valid         & valid         & invalid                    & invalid                & invalid            \\
        \hline
        \textbf{9}  & valid         & invalid       & valid                      & valid                  & valid              \\
        \hline
        \textbf{10} & valid         & invalid       & valid                      & valid                  & invalid            \\
        \hline
        \textbf{11} & valid         & invalid       & valid                      & invalid                & valid              \\
        \hline
        \textbf{12} & valid         & invalid       & valid                      & invalid                & invalid            \\
        \hline
        \textbf{13} & valid         & invalid       & invalid                    & valid                  & valid              \\
        \hline
        \textbf{14} & valid         & invalid       & invalid                    & valid                  & invalid            \\
        \hline
        \textbf{15} & valid         & invalid       & invalid                    & invalid                & valid              \\
        \hline
        \textbf{16} & valid         & invalid       & invalid                    & invalid                & invalid            \\
        \hline
        \textbf{17} & invalid       & valid         & valid                      & valid                  & valid              \\
        \hline
        \textbf{18} & invalid       & valid         & valid                      & valid                  & invalid            \\
        \hline
        \textbf{19} & invalid       & valid         & valid                      & invalid                & valid              \\
        \hline
        \textbf{20} & invalid       & valid         & valid                      & invalid                & invalid            \\
        \hline
        \textbf{21} & invalid       & valid         & invalid                    & valid                  & valid              \\
        \hline
        \textbf{22} & invalid       & valid         & invalid                    & valid                  & invalid            \\
        \hline
        \textbf{23} & invalid       & valid         & invalid                    & invalid                & valid              \\
        \hline
        \textbf{24} & invalid       & valid         & invalid                    & invalid                & invalid            \\
        \hline
        \textbf{25} & invalid       & invalid       & valid                      & valid                  & valid              \\
        \hline
        \textbf{26} & invalid       & invalid       & valid                      & valid                  & invalid            \\
        \hline
        \textbf{27} & invalid       & invalid       & valid                      & invalid                & valid              \\
        \hline
        \textbf{28} & invalid       & invalid       & valid                      & invalid                & invalid            \\
        \hline
        \textbf{29} & invalid       & invalid       & invalid                    & valid                  & valid              \\
        \hline
        \textbf{30} & invalid       & invalid       & invalid                    & valid                  & invalid            \\
        \hline
        \textbf{31} & invalid       & invalid       & invalid                    & invalid                & valid              \\
        \hline
        \textbf{32} & invalid       & invalid       & invalid                    & invalid                & invalid            \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{Combinaciones en el diseño de tests para CreateTaskUseCase}\label{tab:combCreateTaskUseCase}
    \small
    \begin{tabular}{llll}
        \textbf{var1}     & \textbf{var2}     & \textbf{value1} & \textbf{value2} \\
        host              & port              & valid           & valid           \\
        \hline
        host              & port              & valid           & notValid        \\
        \hline
        host              & port              & notValid        & valid           \\
        \hline
        host              & port              & notValid        & notValid        \\
        \hline
        host              & executionMode     & valid           & valid           \\
        \hline
        host              & executionMode     & valid           & notValid        \\
        \hline
        host              & executionMode     & notValid        & valid           \\
        \hline
        host              & executionMode     & notValid        & notValid        \\
        \hline
        host              & communicationMode & valid           & valid           \\
        \hline
        host              & communicationMode & valid           & notValid        \\
        \hline
        host              & communicationMode & notValid        & valid           \\
        \hline
        host              & communicationMode & notValid        & notValid        \\
        \hline
        host              & steps             & valid           & valid           \\
        \hline
        host              & steps             & valid           & notValid        \\
        \hline
        host              & steps             & notValid        & valid           \\
        \hline
        host              & steps             & notValid        & notValid        \\
        \hline
        port              & executionMode     & valid           & valid           \\
        \hline
        port              & executionMode     & valid           & notValid        \\
        \hline
        port              & executionMode     & notValid        & valid           \\
        \hline
        port              & executionMode     & notValid        & notValid        \\
        \hline
        port              & communicationMode & valid           & valid           \\
        \hline
        port              & communicationMode & valid           & notValid        \\
        \hline
        port              & communicationMode & notValid        & valid           \\
        \hline
        port              & communicationMode & notValid        & notValid        \\
        \hline
        port              & steps             & valid           & valid           \\
        \hline
        port              & steps             & valid           & notValid        \\
        \hline
        port              & steps             & notValid        & valid           \\
        \hline
        port              & steps             & notValid        & notValid        \\
        \hline
        executionMode     & communicationMode & valid           & valid           \\
        \hline
        executionMode     & communicationMode & valid           & notValid        \\
        \hline
        executionMode     & communicationMode & notValid        & valid           \\
        \hline
        executionMode     & communicationMode & notValid        & notValid        \\
        \hline
        executionMode     & steps             & valid           & valid           \\
        \hline
        executionMode     & steps             & valid           & notValid        \\
        \hline
        executionMode     & steps             & notValid        & valid           \\
        \hline
        executionMode     & steps             & notValid        & notValid        \\
        \hline
        communicationMode & steps             & valid           & valid           \\
        \hline
        communicationMode & steps             & valid           & notValid        \\
        \hline
        communicationMode & steps             & notValid        & valid           \\
        \hline
        communicationMode & steps             & notValid        & notValid        \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{Test para CreateTaskUseCase}\label{tab:createTaskPairWiseTest}
    \small
    \begin{tabular}{rllllll}
        case & host     & port     & ExeMode  & ComMode  & steps    & Expected Result        \\
        \hline
        1    & valid    & valid    & valid    & valid    & valid    & OK                     \\
        \hline
        2    & valid    & notValid & notValid & notValid & notValid & PortInvalidError       \\
        \hline
        3    & notValid & valid    & notValid & valid    & notValid & HostInvalidError       \\
        \hline
        4    & notValid & notValid & valid    & notValid & valid    & HostInvalidError       \\
        \hline
        5    & ~valid   & valid    & valid    & notValid & notValid & CommunicationModeError \\
        \hline
        6    & ~valid   & notValid & notValid & valid    & valid    & PortError              \\
        \hline
    \end{tabular}
\end{table}

En la instanciación de una nueva Task los factores o variables independientes son:

\begin{itemize}
    \item Number of steps
    \item execution Mode
    \item Communication Mode
\end{itemize}

Las clases de equivalencia:

\begin{itemize}
    \item Number of steps: $0, 1, >2$
    \item execution Mode: Automatic, Manual
    \item Communication Mode: Server Stream,Client Stream, Bidirectional y Unary
\end{itemize}

Por lo tanto existen  $3*2*4 = 24$ posibilidades.
Pares existen 27 que, aplicando pairwise, se reducen a 13 casos.
La eficiencia en reducción de casos disminuye cuanto menos combinaciones hay.
El diseño de los tests queda tal y como se ve en la~\cref{tab:taskTestPairwiseCases}

\begin{table}[H]
    \caption{Tests para la instanciación de Task}\label{tab:taskTestPairwiseCases}
    \small
    \begin{tabular}{ccccl}
        \textbf{}   & \textbf{NSteps} & \textbf{ExeMod} & \textbf{ComMode} & \multicolumn{1}{c}{\textbf{Expected Result}}  \\
        \hline
        \textbf{1}  & 0               & automatic       & serverStream     & NewTaskMustHaveAtLeastOneStepError            \\
        \hline
        \textbf{2}  & 1               & automatic       & clientStream     & OK                                            \\
        \hline
        \textbf{3}  & 1               & manual          & bidirectional    & OK                                            \\
        \hline
        \textbf{4}  & 1               & automatic       & unary            & OK                                            \\
        \hline
        \textbf{5}  & 1               & manual          & serverStream     & OK                                            \\
        \hline
        \textbf{6}  & \textgreater{}2 & manual          & unary            & CommunicationModeCanOnlyHaveOneStepError      \\
        \hline
        \textbf{7}  & \textgreater{}2 & automatic       & serverStream     & CommunicationModeCanOnlyHaveOneStepError      \\
        \hline
        \textbf{8}  & \textgreater{}2 & manual          & clientStream     & OK                                            \\
        \hline
        \textbf{9}  & \textgreater{}2 & automatic       & bidirectional    & ManualBidirectionalTaskOnlyCanHave2StepsError \\
        \hline
        \textbf{10} & 0               & automatic       & clientStream     & TaskMustHaveAtLeastOneStepError               \\
        \hline
        \textbf{11} & 0               & manual          & bidirectional    & TaskMustHaveAtLeastOneStepError               \\
        \hline
        \textbf{12} & 0               & automatic       & unary            & TaskMustHaveAtLeastOneStepError               \\
        \hline
        \textbf{13} & 0               & manual          & serverStream     & TaskMustHaveAtLeastOneStepError               \\
        \hline
    \end{tabular}
\end{table}

Un caso de aplicación donde la arquitectura protege la calidad del sistema de las implementaciones en proceso de investigación ya quedó señalado en el diseño.
El looper es el punto más complejo de la aplicación.
Está muy ligado a la tecnología gRPC\@.
Extraer la lógica perteneciente al Dominio de la interacción con la infraestructura es algo que no se puede diseñar sin conocimiento previo de la tecnología.
En el \textit{Looper}~\cref{lst:Looper} se encuentra el adaptador de comunicación gRPC\@.
Se ha extraído toda la lógica posible a este servicio de dominio, pero dentro de dicho adaptador hay código experimental que puede tener múltiples errores inesperados: no conseguir comunicar con el servicio cliente, timeouts, malas implementaciones de la librería, por ejemplo.
Se ha protegido al Dominio de todo ello mediante una interfaz que garantiza que ante cualquier error se devuelve siempre un resultado.
De esta forma, aunque no funcione correctamente, la lógica de negocio es clara y concisa, dejando al proceso iterativo de ir mejorando la infraestructura.
Toda la comunicación con el cliente se encuentra abstraída mediante una interfaz útil y única para comunicarnos.
Una lógica de negocio que comprende de pocas lineas de código y explican su funcionamiento

En el proceso de descubrimiento del lenguaje se detectó un punto débil en el Dominio.
Cada una de las \textit{gorutines} lanzadas pudiera ocurrir que no consiguiera terminar y se quedara en un proceso infinito.
Para ello, Golang dispone de una herramienta llamada \textit{context} que permite gestionar los timeouts de las \textit{gorutines} evitando que que queden procesos hijos sin control.
No se ha hecho uso de ello porque el coste de cambio no hubiese sido asumible;
quedando por lo tanto como linea futura

Las lineas de código que hay detrás de la interfaz de comunicación son 178, sumado a todos los problemas presentados el trabajo de diseño de un tests que cubra todo es una tarea ardua.
Para cuantificarlo se realiza una aproximación al diseño del test necesario para cubrir el adaptador de comunicación.
Se apreciará que en el mismo diseño de los tests queda patente de forma objetiva la debilidad del código.
El código completo se encuentra en el repositorio \href{https://github.com/Enrikerf/pfm}{github}.
En este ejercicio didáctico se ha simplificando en pseudocódigo:

\begin{verbatim}
connection, err := grpc.Dial()
    serverStream:
        client.CallServerStream(request)
        responseStream.Recv()
    Bidirectional:
        client.CallBidirectional()
        async stream.Recv()
        async stream.Send()
        stream.CloseSend()
    ClientStream:
        client.CallClientStream()
        stream.Send
        stream.CloseAndRecv()
    Unary
        client.CallUnary()
connection.Close()
\end{verbatim}

Hay mucha lógica en un mismo servicio, múltiples responsabilidades y por lo tanto no es un buen diseño.
Como se demuestra mejor es intentando diseñar los tests.
Para empezar, extraer del código las clases de equivalencia y factores es sencillo.
Hay multiples gestiones de errores dispersos por toda su extensión.
Esto ocurre ya sea debido al tiempo, desconocimiento o mala praxis producen códigos de esta magnitud.
La arquitectura nos protege de estas secciones sucias.
Los factores serían:

\begin{itemize}
    \item grpc.Dial(): err, connection
    \item client.CallServerStream(request): err,stream
    \item responseStream.Recv(): EOF,err,nil
    \item client.CallBidirectional(): error,stream
    \item stream.Recv(): EOF,err, result
    \item stream.Send(): EOF, nil,err
    \item stream.CloseSend() err,nil
    \item client.CallClientStream(): err, stream
    \item stream.Send: err, nil
    \item stream.CloseAndRecv(): err, nil
    \item client.CallUnary(): err,nil
    \item connection.Close(): err, nil
\end{itemize}

El concepto de factor en estos casos es todavía más relevante.
La mala aplicación podría llevar a un mal diseño de los tests y a hacerlo aún más complejo.
Aunque hay factores que tienen tres respuestas posibles, EOF y nil tienen que ir de la mano.
Ambas significan que no ha habido error: primero obtienes un nil como error y luego obtienes un error tipo EOF que significa que todo ha terminado correctamente.
El otro caso es obtener un error distinto de EOF, si esto ocurre no importa cuántas veces haya ocurrido el caso sin error, será error igualmente.
Se aprecia la diferencia entre entradas/salidas y factores/clases de equivalencia.
Con lo cual las clases de equivalencia para los distintos factores son:

\begin{itemize}
    \item grpc.Dial(): err, connection
    \item client.CallServerStream(): err,stream
    \item responseStream.Recv(): nil\&EOF,err
    \item client.CallBidirectional(): error,stream
    \item stream.Recv(): nil\&EOF,err
    \item stream.Send(): nil\&EOF,err
    \item stream.CloseSend() err,nil
    \item client.CallClientStream(): err, stream
    \item stream.Send: err, nil
    \item stream.CloseAndRecv(): err, nil
    \item client.CallUnary(): err,nil
    \item connection.Close(): err, nil
\end{itemize}

Para este caso se obtienen $ 2^{12} = 4096 $ combinaciones posibles que pairwise reduce a 59 tests.
Aquí se ve la potencia del método.
Volviendo posible un testing con ciertas garantías incluso en un código mal diseñado como el que nos ocupa.
