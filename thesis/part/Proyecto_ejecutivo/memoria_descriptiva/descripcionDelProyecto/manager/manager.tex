\begin{figure}[H]
    \centering
    \includegraphics[height=0.4\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/managerServerConcept}
    \caption[Diagrama componentes]{}\label{fig:managerServerConcept}
\end{figure}

\subparagraph{Dominio}

En el diagrama UML~\ref{fig:managerDomain} vemos que el dominio de Manager se compone de dos modulos: uno para las tareas y otro para los resultados. Vamos a ir explicando uno por uno:

\begin{figure}[H]
    \centering
    \includegraphics[height=0.4\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/managerDomain}
    \caption[Diagrama de objetos de dominio]{}\label{fig:managerDomain}
\end{figure}

\begin{itemize}
    \item CoreDomain
    \begin{itemize}
        \item Id todos los ids extenderan de este id, contiene un uuid, no sabemos que paquete usaremos para generarlos, es una de las pocas dependencias externas que vamos a tener dentro del dominio y queremo encapsularla lo máximo posible por si hubera que cambiarla. Además de esta forma los ids de las entities no se confunden en su tipo. si por ejemplo buscas una task mediante un id que corresponde a un result, si fueran del mismo tipo daría lugar a confusión porque no lo encontraríamos pero no nos advertiría de nuestro error
        \item Event todos los eventos del sistema extenderan del evento este
    \end{itemize}
    \item TaskDomain
    \begin{itemize}
        \item Task: AggregateRoot
        \item TaskId
        \item Host: es un Value Object compuesto por el valor del host, es un string pero el Value Object garantiza que es un valor válido, si no devuelve un error
        \item Port: es un Value Object compuesto por el valor del puerto, es un string pero el Value Object garantiza que es un valor válido, si no devuelve un error
        \item CommunicationMode: es un enum para expresar esa tarea de las formas de comunicación posibles que hay entre dos servidores cual sera la utilizada
        \begin{itemize}
            \item UNARY
            \item SERVER\_STREAM
            \item CLIENT\_STREAM
            \item BIDIRECTIONAL
        \end{itemize}
        \item ExecutionMode: es un enum
        \begin{itemize}
            \item MANUAL
            \item AUTOMATIC
        \end{itemize}
        \item Status: es un enum
        \begin{itemize}
            \item PENDING
            \item RUNNING
            \item SUCCESSFUL
            \item FAILED
        \end{itemize}
        \item Step: cada tarea puede componerse en distintos pasos. Por ejemplo queremos poder poner en marcha el motor durante 15 segudos y luego llevarlo a una posición de inicio
        \begin{itemize}
            \item StepId
            \item sentence: será un string de contenido libre que el servidor cliente ejecutará en su sistema, dependerá de él tener instalado dicho programa y corroborar que la sintaxis es la correcta
        \end{itemize}
        \item TaskCreatedEvent. Cuando se cree una tarea se emitirá un evento, habrá un manejador de eventos que actuará en consecuencia. Si es una tarea automatizada y el loop de ejecución está parado lo pondrá en marcha.
        \item TaskModifiedEvent: si una tarea es modificada se emitirá un evento, habrá un manejador de eventos que actuará en consecuencia. Si la tarea vuelve a ser puesta a pending, es automatizada y el loop de ejecución está parado lo pondrá en marcha
        \item TaskDeletedEvent: si una tarea es modificada se emitirá un evento, habrá un manejador de eventos que actuará en consecuencia.
    \end{itemize}
    \item ResultDomain
    \begin{itemize}
        \item BatchId
        \item Batch: aggregate root para referencial el conjunto de resultados correspondiente a la ejecución de una tarea. Una tarea se puede ejecutar varias veces, cada vez con distintos resultados. Para agruparlos necesitaremos este aggregate root
        \item ResultId
        \item Result: contendrá un string con el resultado en plano. Cada tarea y proceso tendrá a su disposición este strings para crear su propio formato de respuesta. Será tarea de cada cliente interpretarlos.
    \end{itemize}
\end{itemize}

\subparagraph{casos de uso}

Vamos a describir los casos de uso que podrán ejecutarse en el programa manager. Tenemos 2 Entities y dos aggregate root.

\begin{itemize}
    \item Task
    \subitem Step
    \item Batch
    \subitem Result
\end{itemize}

Vamos a hacer el CRUD completo de Task; este contempla la edición de los steps a través de Task ya que es su aggregate root y por definición no se debe poder acceder a sus componentes si no es a través del aggregate. De Batch no vamos a hacer el update porque no tiene sentido a nivel de caso de uso poder actualizar un Batch, teniendo en cuenta que sus variables están ligadas al Task con el que se encuentra ligado y las fechas no dependen del usuario. y lo mismo pasa con result


\textbf{crear tarea}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/createTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:createTaskUseCase}
\end{figure}

\textbf{obtener tarea}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/getTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:getTaskUseCase}
\end{figure}

\textbf{listar tareas}

Uno de los puntos más amplios en una API CRUD es el filtrado de datos. No entra dentro del ámbito de este proyecto crear un sistema de filtrado que incluya la paginación. En este caso habría que crear una nomenclatura de filtros de cara al usuario y un sistema que los procese, devolviendo error ante un filtro erroneo o el listado de tareas que responda a dicho filtro. En nuestro caso devolveremos todas las tareas.

\textbf{actualizar tareas}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.5\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/updateTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:updateTaskUseCase}
\end{figure}

\textbf{eliminar tareas}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/deleteTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:deleteTaskUseCase}
\end{figure}

\textbf{TaskEventHandler}

tanto en TaskCreatedEvent como TaskUpdatedEvent el handler va a ser el mismo. TaskDeletedEvent lo dejaremos en este diseño inicial.

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/taskEventHandlerUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:taskCreatedEventHandtaskEventHandlerUseCaselerUseCase}
\end{figure}

\textbf{TaskLoop: ejecutar tareas automáticas pendientes}

Una vez que el TaskEventHandler ponga en marcha el TaskLoop este obtendrá de base de datos todas las tareas automáticas pendientes y iterando sobre ellas lanzará un hilo de ejecución para ejecutarlas. Una vez terminadas todas volverá a intentar obtener tareas pendientes ya que en el periodo que haya estado ejecutandolas pueden haberse introducido nuevas. Si no hay más tareas pendientes el loop se desactivará.

Un punto a mencionar de este Task loop es que se implementará en aplicación porque aquí intervendrán todavía puntos de la aplicación y la tecnología que no están investigados y son complejos. Es donde esta arquitectura mostrará toda su flexibilidad y fiabilidad de cara a proteger los elementos básicos de la aplicación de los cambios.

Una vez desarrollado, o puede que incluso durante el mismo desarrollo habrá en este proceso muchos conceptos que descubriremos core de la aplicación y debieran ser dominio, pero como tenemos que descubrirlos vamos a implementarlos en aplicación haciendo uso de interfaces de infraestructura y de elementos de dominio. Si vemos claramente que algo puede convertirse en dominio lo introduciremos.

\sout{Será el único punto en donde una interfaz de dominio será implementada por un elemento de aplicación en vez de infraestructura.} \textcolor{red}{El diseño de esto es complejo y todavía no lo tengo. Event handler necesita todo para crearse?}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.3\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/executeTaskLoop}
    \caption[Diagrama de objetos de dominio]{}\label{fig:executeTaskLoop}
\end{figure}

\textbf{TaskProcessor} que aparece en la figura\ref{fig:executeTaskLoop} en color verde es el proceso asíncrono donde se hará uso del las gorutines que permiten la gestión de tareas asíncronas de forma sencilla. Una de las bondades que vende el lenguaje y donde se pondrá a prueba. se lanzarán todas las tareas pendientes en paralelo y se hará un bloqueo del loop mientras todas terminan. Como en el tiempo que esto ocurre han podido entrar nuevas tareas pendientes se repetirá la lógica hasta que no haya más.

Se puede ver el flujo lógico de esta lógica en la figura\ref{fig:1-TaskProcessor}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.5\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/1-TaskProcessor}
    \caption[Diagrama de objetos de dominio]{}\label{fig:1-TaskProcessor}
\end{figure}


\textbf{Create Batch}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/createBatchUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:createBatchUseCase}
\end{figure}

\textbf{Delete Batch}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/deleteBatchUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:deleteBatchUseCase}
\end{figure}

\textbf{obtener batch}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/getBatchUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:getBatchUseCase}
\end{figure}

\textbf{listar batches}

Uno de los puntos más amplios en una API CRUD es el filtrado de datos. No entra dentro del ámbito de este proyecto crear un sistema de filtrado que incluya la paginación. En este caso habría que crear una nomenclatura de filtros de cara al usuario y un sistema que los procese, devolviendo error ante un filtro erroneo o el listado de tareas que responda a dicho filtro. En nuestro caso devolveremos todas las tareas.

\textbf{Obtener los results de un batch}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/getBatchResultsUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:getBatchResultsUseCase}
\end{figure}

\textbf{Execute task manually}

\textcolor{red}{Ahora mismo es el stream result}

solo se puede ejecutar una tarea manual por vez, en este primer diseño. El motivo es que como se quiere graficar en tiempo real la respuesta, por ejemplo para monitorizar la velocidad del motor en tiempo real, no queremos meternos en la complejidad de graficar varios resultados a la vez.

Podemos apreciar que cuando se ejecuta manualmente una tarea se pone en estado running y entra enun bucle infinito. Hasta que un usuario no pona esa tarea en DONE no para de ejecutar el comando. O Hasta que uno de los steps para el proceso

\textcolor{red}{Decir que esto es el primer esbozo. Se deja claro que depende mucho de como funcione el RPC o las limitaciones tecnicas que nos encontremos. esto no esta implementado asi. el diagrama esta mal porque ejecuta una y otra vez los steps, en lo que hay ahora solo ejecuta el primer step y se queda esperando}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.3\textheight]{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/uml/1-executeTaskManual}
    \caption[Diagrama de objetos de dominio]{}\label{fig:1-executeTaskManual}
\end{figure}

\subparagraph{estructura de carpetas}

Una de las partes mas importantes de un proyecto de software es que la estructura de carpetas hable sobre cómo está diseñado el software, sobre de qué va el software. qué es lo que hace y sobre que componentes interactua

\input{./part/Proyecto_ejecutivo/memoria_descriptiva/descripcionDelProyecto/manager/folder_estructure_manager.tex}

