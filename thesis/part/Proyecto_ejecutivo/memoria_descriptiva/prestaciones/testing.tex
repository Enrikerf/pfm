
Proteger el sistema frente al error humano es esencial para garantizar la entrega de código con seguridad y calidad.
Para ello se emplearán herramientas de \gls{CI/CD} (\textit{Continuous delivery/Continuous integration} o Entrega Continua/Integración Continua) que se encargarán de realizar comprobaciones antes de permitir la llegada a servicio del nuevo código y el despliegue automático de dicho código en el entorno final.
Este proyecto se centra en los primeros, CI \textit{Continuous integration}, debido a que no se dispondrá de servidores sobre los que desplegar de forma final.

CI/CD implica el uso de sistemas de control de versiones, servidores de automatización de compilación y pruebas, y herramientas de automatización de implementación y entrega.
Estas herramientas permiten que los desarrolladores integren sus cambios de código en un repositorio central, donde se desencadenan automáticamente pruebas y compilaciones para detectar cualquier error y garantizar que el código se pueda implementar sin problemas.

Los tests son un apartado importante en la garantía de entrega de código libre de errores.
En este proyecto se va a centrar el control de calidad en el Dominio.
Es decir, va a existir una suite de test unitarios por cada elemento de Dominio.
los test de integración y de \gls{E2E} (\textit{End to End} o de extremo a extremo) quedan fuera de esta primera versión del sistema.
Las técnicas utilizadas para el desarrollo de los tests encuentran su origen en las siguientes condiciones de contorno:

\begin{itemize}
    \item Si el código de pruebas no ahorra más esfuerzo de lo que cuesta desarrollarlo entonces se está perdiendo dinero.
    \item No se puede entregar un producto que no tiene ninguna clase de garantía de su correcto funcionamiento o acotado su margen de error.
\end{itemize}

Se va a trabajar dentro de esos dos límites: deben existir tests que garanticen y especifiquen el grado de calidad acotado al presupuesto que se dispone.
Para poder expresar de una forma cuantitativa que los tests están correctamente diseñados y desarrollados primero se necesita definir ineficaz e ineficiente:

\begin{itemize}
    \item Eficaz: Capacidad de lograr el efecto que se desea o se espera.
    \item Eficiente: Capacidad de lograr los resultados deseados con el mínimo posible de recursos.
\end{itemize}

De existir un numero exacto de pruebas óptimas, para cubrir todas la posibilidades, desarrollar menos es ineficaz y más es ineficiente.
El trabajo de diseño de los tests consta de escoger una solución de compromiso entre eficacia y eficiencia.
No se puede no probar y no existen recursos para probar todo.
En un ejemplo: para un método que recibe la información de un formulario de ocho campos con diez posibles valores diferentes cada uno se obtendría un conjunto de $8^{10} = 1,073,741,824$ casos de prueba.
Esta táctica de pruebas siendo la más obvia la mayor parte de las veces será inviable.

Este proyecto utilizará pruebas de caja negra.
Las pruebas de caja negra se basan en diseñar un test sin suponer cómo va a estar desarrollado el código.
Se diseña el caso de uso al que va a tener que enfrentarse y el resultado esperado.
Para evitar la prueba exhaustiva existen las siguientes técnicas:

\begin{itemize}
    \item Variables independientes.
    \subitem Clases de equivalencia.
    \subitem Método de valores límite.
    \item Variables dependientes.
    \subitem Vector de pares.
\end{itemize}

\textbf{Variables independientes}

Su enfoque es reducir el conjunto de los valores posibles de cada entrada a un subconjunto representativo y reducido del conjunto original que asegure una cierta garantía de cobertura.
La combinación de todos estos valores representativos de todas las entradas reducirá drásticamente el conjunto de casos de prueba final.
Estas técnicas son Clases de Equivalencia y Análisis de Valores Límite;
la segunda se aplica sobre la primera.

Las clases de equivalencia son un subconjunto de valores de la entrada que el sistema debería manejar de forma equivalente en el ejercicio del \gls{SUT} (System Under Test o sistema bajo prueba).
Para cada entrada deben repartirse todos sus posibles valores en un número finito de clases de equivalencia que cumplan la siguiente propiedad: la prueba de un valor representativo de una clase de equivalencia permite suponer “razonablemente“ que el resultado obtenido será un proceso similar que el obtenido probando cualquier otro valor de esa clase de equivalencia.
Es un proceso heurístico y se obtiene analizando:
\begin{itemize}
    \item La especificación (caja negra) que describe las características del proceso que debe cumplir la implementación.
    \item Las salidas del SUT, que pueden aportar criterios para la partición en clases de equivalencia.
    \item Las precondiciones del SUT, que aportan clases de equivalencia de error.
\end{itemize}

los pasos para diseñar el test son:
\begin{enumerate}
    \item Definir las Clases de Equivalencia de cada factor.
    \item Escoger un valor de cada clase.
    \item Generar todas las combinaciones de todos los valores.
    \item Eliminar aquella combinaciones que no son factibles.
    \item Añadir la salida correspondiente a cada combinación de valores de entrada.
\end{enumerate}

Para escoger dentro de una clase de equivalencia un valor se aplica la técnica de los valores límites.
Esta técnica es aplicable a la partición de clases de equivalencia cuando sus valores tiene un orden total, o sea, que para toda pareja de valores distintos se puede comprobar si uno es mayor que otro o viceversa.
Por ejemplo, enteros, reales, caracteres por su código, cadenas de caracteres por su orden lexicográfico, enumerados por su ordinal, fechas o horas.
Son valores dentro de esa clase de equivalencia para el que cambia el comportamiento del SUT respecto del valor anterior.

La justificación se basa en la evidencia experimental de que “los errores se esconden en los rincones y se aglomeran en los límites” [Beizer] y por tanto se aumenta el conjunto de casos de prueba para mejorar la eficacia de encontrar errores.
Es decir, que dentro de una clase de equivalencia puede requerirse el testeo de varios valores.

Se expone un ejemplo que muestran la diferencia entre: parámetro de entrada, factor y clase de equivalencia.

Enfrentando una función que acepta como parámetro de entrada un texto.

\begin{verbatim}
    funcion de nextDay(string day){...}
\end{verbatim}

En el diseño del test no se puede asumir la implementación.
La entrada puede ser cualquier cadena de caracteres, es decir, infinitas posibilidades.
El factor es un elemento de definición subjetiva que en este caso se opta por elegir el concepto ´día de la semana´.
Concepto distinto a la entrada: cadena de caracteres.
Las clases de equivalencia para ese factor ha de englobar todas las posibilidades, para este caso: que la entrada sea invalida o que sea válida.

\begin{itemize}
    \item Inválido: cualquier cadena de caracteres inválida, no es un día de la semana.
    \item Válido: cualquier día de la semana.
    Lunes, martes, miércoles, jueves, viernes, sábado o domingo.
\end{itemize}

En este punto se podría escoger cualquier valor dentro de esas dos clases, por ejemplo:

\begin{itemize}
    \item Inválido: cualquier cadena de caracteres inválida \(\longrightarrow\) resultado esperado: error.
    \item Válido: lunes \(\longrightarrow\) resultado esperado: martes.
\end{itemize}

Siguiendo esta metodología se obtiene una garantía: Explicar metodológicamente por qué se han hecho los tests y los valores escogidos y que cobertura se está ofreciendo.
Aplicando la técnica de los valores límites se concibe el domingo como el último día, después se debe volver al lunes.
Es decir, es el valor límite dentro de la clase de equivalencia.
Garantizando elegir con criterio dentro de los casos de la clase de equivalencia.
Los tests son:

\begin{itemize}
    \item Inválido: cualquier cadena de caracteres inválida \(\longrightarrow\) resultado esperado: error.
    \item Válido límite inicial: lunes \(\longrightarrow\) resultado esperado: martes.
    \item Válido límite final: domingo \(\longrightarrow\) resultado esperado: lunes.
\end{itemize}

\textbf{Variables dependientes}\label{variablesDependendientes}

Dentro de los métodos de variables dependientes se utilizará el método de \textit{Pairwise}, también conocido como pruebas de combinaciones de pares.
Es una técnica de diseño de pruebas que permite reducir el número de casos necesarios para lograr una cobertura exhaustiva.
En lugar de probar todas las combinaciones posibles de los parámetros, el método identifica las combinaciones de pares que tienen el potencial de causar errores.
Estas combinaciones de pares se seleccionan utilizando un algoritmo que busca minimizar el número de casos de prueba necesarios sin sacrificar la calidad de la cobertura de pruebas.

El método de Pairwise fue introducido por David C. Kuhn en un artículo~\cite{37051} publicado en 1997.
Desde entonces, ha sido utilizado en la industria de software y ha sido objeto de numerosos estudios y mejoras por parte de investigadores y practicantes.
Es importante tener en cuenta que el método de Pairwise no es una técnica infalible, ya que no cubre todas las posibilidades.
Es una técnica efectiva para la reducción del número de casos de prueba necesarios para lograr una cobertura razonable.

En un ejemplo extraído de~\cite{Bach04pairwisetesting} se analiza un software con un menú de botones.
Para hacer un testeo exhaustivo se han de analizar 12,288 casos;
ese coste de calidad no es asumible para todos los proyectos.
En este mismo estudio se reducen a 10 casos con este método.
Es una metodología para escoger los tests que más aportan valor de cara a la seguridad sin perder pragmatismo y economía.
Para el cálculo de los pares hay varios software disponible como páginas web que permiten el cálculo de forma rápida.

Con estos métodos presentados: clases de equivalencia, método de valores límite, vector de pares.
Se garantizarán que pruebas cumplan con las características de ser:

\begin{itemize}
    \item Inocuas
    \item Automatizadas
    \item Auto-verificables
    \item Repetibles
    \item Independientes
    \item Rápidas
\end{itemize}

Un código se demuestra que es correcto cuando es fácil de testear.
Como referencia, si el diseño un test se complica, no se consigue aislar las características a testear, definir los factores, las clases de equivalencia o se obtiene un número inabarcable de tests es síntoma de un código mejorable.