Para exponer una solución de forma que sea útil a la hora de tomar decisiones de cara a invertir recursos en un proyecto tiene que exponerse de forma que se entienda lo que se va a desarrollar y el valor que aporta. Para combinarlo con una metodología ágil que suponga la entrega de valor de forma iterativa, evitar la parálisis por análisis, no centrarse en el imposible de intentar describir detalles técnicos que han de ser investigados, analizados o puestos a prueba con su propia implementación, vamos a elaborar esta memoria descriptiva como primera entrega de valor. Serviría como paso previo a la memoria de ejecución donde ya se describiría los pasos tomados en el curso de la implementación, los cambios y decisiones que se toman en cada entrega de valor.

Para poder empezar la descripción primero hay que presentar un vocabulario básico.

Para describir los 3 programas que se van a diseñar: gestor de tareas, cliente y controlador pid. ( la interfaz gráfica se va a tratar aparte ) vamos a definir una serie de conceptos básicos que van a ser utilizados en todos. Todo programa va a estar dividido en los siguientes componentes básicos:

\begin{itemize}
    \item Dominio
    \item Aplicación
    \item Infraestructura
\end{itemize}

a cada uno de esos conceptos le vamos a llamar capas y cada capa tiene como objeto desarrollar un aspecto de dicha aplicación. Resumido de una forma llana

\begin{itemize}
    \item Dominio: responde a qué
    \item Aplicación: responde a cómo
    \item Infraestructura: responde a traves de qué
\end{itemize}

En un ejemplo rápido, si estamos manejando el concepto ¨Tarea¨ la definición de qué es una tarea es una cosa core, básica del programa diseñado. Lo que definamos como tarea tiene que ser estable, duradero. Cambiar mi definición de Tarea tocará la raiz de la solución que se presenta. Todo dependerá de qué consideremos una Tarea. Es por eso que lo llamamos Dominio. Todo debe depender del dominio y debe estar diseñado con cuidado. Abierto a añadir funcionalidades pero cerrado al cambio. Es decir podemos complementar la definición de tarea con una definición más completa y amplia, pero cambiar su significado es algo que invalidará tanto código que estaríamos hablando de otro software completamente nuevo.

Por ejemplo, si definimos tarea como un nombre y una fecha de comienzo. La tarea es un elemento de software que se compone de un campo para nombrarla y otro para guardar su valor:

Tarea: Hacer proyecto.
Fecha de comienzo: hoy.

y defino un programa que me dice la tarea más antigua. Si añadimos un campo nuevo con fecha de fin no rompemos nada. Añadimos funcionalidad al programa. Pero si decido que la fecha de comienzo no es importante elimino el campo y lo substituyo por esfuerzo necesario. he invalidado todo el concepto de tarea.

en el primer caso he definido Tarea como un concepto con fecha de inicio y en el otro la defino como algo que cuesta dias de esfuerzo. Por supuesto podría añadir en vez de sustituir. y de eso se trata. Definir qué es sobre lo que estamos hablando de forma esencial.

Siguiendo el mismo ejemplo Imaginemos que ya tenemos como dominio, concepto de Tarea, un elemento con nombre, fecha de inicio. Si queremos garantizar que no haya dos tareas el mismo día, antes de guardar esa tarea habremos de buscar si existe otra hoy y señalar al usuario si no puede introducir otra. Esto corresponde a una logica de la interacción entre los conceptos de dominio: las tareas se relacionan entre ellas bloqueando días, esto lo llamamos aplicación o capa de aplicación. antes de guardar hay que checkear que no existe otra hoy.

En pseudo código:
\begin{verbatim}
ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        if(!Dominio.HoyEstáLibre()){
            Error
        }
        Dominio.GuardarNuevaTarea(nombre)
    }
}
\end{verbatim}

\begin{itemize}
    \item Dominio(qué): las tareas se pueden crear
    \item Aplicación(cómo): comprobando que el día está libre
    \item Y  nos queda la última pregunta: a través de qué. Es decir a través de qué se comprueba que el día está libre y a través de qué tecnología se guarda?
\end{itemize}

La última pregunta es dónde se puede llegar a tender a emplear más minutos de investigación, configuración, desarrollo, discursiones y probablemente sea la más interesante desde un punto de vista puramente técnico. En este ejemplo: lo guardamos en una base de datos relacional, no relacional. escribimos el programa en un lenguaje en otro... Cómo va a ser el proceso de chequeo de fechas, guardamos en un formato, en otro, cuan eficiente es esa comprobación? cuando empezará a haber problema por el tamaño de la base de datos de cara a esa comprobación?

Todas esas preguntas son importantes e interesantes. Afectaran al precio de la solución, a la versatilidad o incluso a la viabilidad, pero desde un punto de vista empresarial o de ingeniería es un error a todas luces responder a esos problemas sin haber resuelto el problema de qué es lo que vamosa controlar y cómo lo vamos a controlar para poder presentarlo al cliente, venderlo, mejorar el diseño hasta que sea interesante para el cliente.

En una analogía a la construcción si un cliente te pide un espacio para almacenar, lo que hay que solucionar es el qué quieres guardar, cómo lo quieres guardar y no centrarse en cómo van a ser los cimientos, si la estructura va a ser de madera, metal o cemento, es un paso posterior. Si es carton y tienes que meter pales con un camión hay que centrarse en diseñar un espacio en el que no haya humedad, donde haya una zona de carga y descarga, un espacio para maniobra de los traspalés y una vez diseñada la solución ver qué materiales son los más adecuados para responder a esa solución: una nave industrial? un simple trastero? dependerá de la cantidad. Lo que intenta el análisis del Dominio y la aplicación es descubrir cuáles son las necesidades básicas, las funcionalidades básicas para poder evaluar una solución técnica adecuada.

El problema de la analogía es que es un poco contra-intuitivo porque el el software se va descubriendo (No se si meterme en dar valoracion de las diferencias entre el software y los productos fisicos de cara a ir descubriendo conforme programas)

El objetivo por tanto de este diseño que divide en estas tres capas es separar según los siguientes criterios

Hacer tabla de esto?
\begin{itemize}
    \item Dominio:          tendencia al cambio baja    dependencia a software nula*)    Interacción con No tecnicos alta
    \item Aplicación:       tendencia al media          dependencia a software externo nula* Interacción con No tecnicos alta
    \item Infraestructura:  tendencia al alta           dependencia a software  Interacción con No tecnicos baja
\end{itemize}

Del dominio se acaba hablando con los managers, comerciales, clientes y es un lenguaje comun a toda la compañía, se suele tner que hacer diagramas, gráficos, dosieres de ello. Si no está separado tiene a ocultarse entre detalles técnicos, se vuelve dificil de explicar qué es lo que se está manejando y cómo funciona. Degenera.

Falta un dejalle en nuestro ejemplo de tarea. No es pequeño

\begin{verbatim}

ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        if(!Dominio.HoyEstáLibre()){
            Error
        }
        Dominio.GuardarNuevaTarea(nombre)
    }
}

\end{verbatim}


es la comprobación de que el día está libre tan importante en nuestro software que no es una forma de interaccionar de las tareas
si no un requisito indispensable? lo que no estamos preguntando es si es parte del dominio o es una simple funcionalidad de Crear la tarea hoy. Por ejemplo veamos este codigo

Supongamos que consideramos tan importante esta comprobación que pasamos la comprobación dentro de la funcion GuardarTareaNueva de domino para que nadie pueda crear una tarea en ninguna parte del codigo en un dia ocupado por error. Imaginamos que llega otra funcionalidad de crear tareas en otros dias que no sean hoy y abrimos funcionalidad pero no la cambiamos, podemos modificar nuestro codigo de crear tarea hoy para que pase la fecha de hoy pero permitir que se cree otra funcion que permita pasar otra fecha.

\begin{verbatim}
ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        Dominio.GuardarNuevaTarea(nombre,hoy)
    }

    CrearTareaEnFecha(nombre,fecha){
        Dominio.GuardarNuevaTarea(nombre,fecha)
    }
}

\end{verbatim}

Suponiendo que dominio.guardarTarea ya hace la comprobación siempre


Ahora planteemos que llega el cliente y quiere tener la posibilidad de crear dias saturados de tareas pero seguir pudiendo crear tareas con la seguridad de que no hay más tareas ya no podriamos hacer esto:

\begin{verbatim}

ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        Dominio.GuardarNuevaTarea(nombre,hoy)
    }

    CrearTareaEnFecha(nombre,fecha){
        Dominio.GuardarNuevaTarea(nombre,fecha)
    }

    CrearTareaHoyAunqueHayaMas(nombre){
        -->>> Dominio.GuardarNuevaTarea(nombre) // No funcionaria
    }

}
\end{verbatim}

porque Dominio.GuardarNuevaTarea ya hace la comprobación por dentro. Decidir cómo funciona el dominio.

Decidir qué partes son de aplicación y qué partes son de dominio es una tarea continua. No es fácil discernirlo en todos los casos. Y es por esto que esta división cobra todavía más sentido. Qué cosas se meten en dominio o se sacan aplicación es una tarea constante y compleja que si mezclamos con la infraestructura no nos deja ver esta cosas de forma rápida y clara.

Por supuesto podriamos crear dos funciones de dominio

GuardarNuevaTareaComprobando()
GuardarNuevaTareaSinComprobar()

precisamente ahí está el tema. En ir definiendo el dominio de forma que se pueda ampliar la funcionalidad pero que no se tenga que reescribir la funcionalidad.

El ejemplo de un proceso para no sufrir en estos cambios seria

V0

\begin{verbatim}
ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        if(!Dominio.HoyEstáLibre()){
            Error
        }
        Dominio.GuardarNuevaTarea(nombre)
    }
}

Dominio{
    Dominio.GuardarNuevaTarea(nombre)
}

\end{verbatim}

V1

\begin{verbatim}
ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        Dominio.GuardarNuevaTareaComprobandoFecha(nombre,hoy)
    }

    CrearTareaEnFecha(nombre,fecha){
        Dominio.GuardarNuevaTareaComprobandoFecha(nombre,fecha)
    }
}


Dominio{
    Dominio.GuardarNuevaTarea(nombre)
    Dominio.GuardarNuevaTareaComprobandoFecha(nombre,fecha){
        if(!Dominio.HoyEstáLibre()){
            Error
        }
        Dominio.GuardarNuevaTarea(nombre)
    }
}

\end{verbatim}

V3

\begin{verbatim}

ComponenteDeAplicacion{

    CrearTareaHoy(nombre){
        Dominio.GuardarNuevaTareaComprobandoFecha(nombre,hoy)
    }

    CrearTareaEnFecha(nombre,fecha){
        Dominio.GuardarNuevaTareaComprobandoFecha(nombre,fecha)
    }

    CrearTareaHoyAunqueHayaMas(nombre){
        Dominio.GuardarNuevaTarea(nombre,fecha)
    }
}


Dominio{
    Dominio.GuardarNuevaTarea(nombre)
    Dominio.GuardarNuevaTareaComprobandoFecha(nombre,fecha){
        if(!Dominio.HoyEstáLibre()){
            Error
        }
        Dominio.GuardarNuevaTarea(nombre)
    }
}
\end{verbatim}

Lo importante, y por lo que se expone un ejemplo de este proceso es que se puede apreciar que en el descubrimiento del codigo final se esta hablando en terminos llanos, entendibles por todo el mundo sobre como funcionan las cosas, es un proceso en el que interviene todo el equipo-empresa. Que se discute cómo tienen que funcionar las cosas. En tener controlada esta parte es donde se garantiza la calidad. Veremos muchos ejemplos de decisiones de division applicacion-dominio en la memoria descriptiva

luego en la descripcion del proceso de ejecucion podremos ver cambios en estas decisiones conforme se va desarrollando la solución y cómo haber definido esta división y estructura ayuda a la gestion-comprension-documentación y llegada a buen puerto de la funcionalidad del software.




Herramientas descriptivas: UML, pseudocodigo, estructura de ficheros

\subsubsection{Definiciones}
    \input{./part/memoria_descriptiva/definiciones.tex}
\subsubsection{Diseño DDD}

Aquí ya si ir entidad por entidad exponiendo
explicar TDD Aquí un poco de teoría del testeo que se va a garantizar



