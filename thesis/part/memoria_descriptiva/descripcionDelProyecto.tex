
\begin{figure}[H]
    \centering
    \includegraphics[height=0.4\textheight]{part/memoria_descriptiva/systemConcept}
    \caption[]{}\label{fig:systemConcept}
\end{figure}

Los componentes de esta solucion seran:
\begin{itemize}
    \item el manager server que guardará las tareas, las ejecutará y guardará el resultado.
    \item el client server que recepcionará las llamadas del manager con el comando y las ejecutará en el servidor cliente devolviendo los resultados al manager
    \item el programa a ejecutar. En nuestro caso haremos pruebas con varios ejecutables básicos, pero habrá un programa de control PID par aun motor de corriente continua
\end{itemize}

Se puede ver un diagrama conceptual del sistema en la figura~\ref{fig:systemConcept}. Vamos a proceder a describir cada uno de los programas de forma detallada. Esta descripción estará compuesta de los siguientes elementos:

\begin{itemize}
    \item diagrama de los componentes con los elementos con los que interacciona
    \item diagrama de objetos de sus elementos de dominio
    \item casos de uso: descripción y diagrama
    \item diagramas de procesos
    \item estructura de carpeta para la organización del código
\end{itemize}

\paragraph{Manager Server}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.4\textheight]{part/memoria_descriptiva/managerServerConcept}
    \caption[Diagrama componentes]{}\label{fig:managerServerConcept}
\end{figure}

\subparagraph{Dominio}

En el diagrama UML~\ref{fig:managerDomain} vemos que el dominio de Manager se compone de dos modulos: uno para las tareas y otro para los resultados. Vamos a ir explicando uno por uno:

\begin{itemize}
    \item Core
        \begin{itemize}
        \item Id todos los ids extenderan de este id, contiene un uuid, no sabemos que paquete usaremos para generarlos, es una de las pocas dependencias externas que vamos a tener dentro del dominio y queremo encapsularla lo máximo posible por si hubera que cambiarla. Además de esta forma los ids de las entities no se confunden en su tipo. si por ejemplo buscas una task mediante un id que corresponde a un result, si fueran del mismo tipo daría lugar a confusión porque no lo encontraríamos pero no nos advertiría de nuestro error
        \item Event todos los eventos del sistema extenderan del evento este
    \end{itemize}
    \item Task
        \begin{itemize}
        \item TaskId
        \item Host: es un Value Object compuesto por el valor del host, es un string pero el Value Object garantiza que es un valor válido, si no devuelve un error
        \item Port: es un Value Object compuesto por el valor del puerto, es un string pero el Value Object garantiza que es un valor válido, si no devuelve un error
        \item CommunicationMode: es un enum para expresar esa tarea de las formas de comunicación posibles que hay entre dos servidores cual sera la utilizada
            \begin{itemize}
                \item UNARY
                \item SERVER\_STREAM
                \item CLIENT\_STREAM
                \item BIDIRECTIONAL
            \end{itemize}
        \item ExecutionMode: es un enum
            \begin{itemize}
                \item MANUAL
                \item AUTOMATIC
            \end{itemize}
        \item Status: es un enum
            \begin{itemize}
                \item PENDING
                \item RUNNING
                \item SUCCESSFUL
                \item FAILED
            \end{itemize}
    \end{itemize}
    \item Step: cada tarea puede componerse en distintos pasos. Por ejemplo queremos poder poner en marcha el motor durante 15 segudos y luego llevarlo a una posición de inicio
    \begin{itemize}
      \item StepId
      \item sentence: será un string de contenido libre que el servidor cliente ejecutará en su sistema, dependerá de él tener instalado dicho programa y corroborar que la sintaxis es la correcta
    \end{itemize}
    \item TaskCreatedEvent. Cuando se cree una tarea se emitirá un evento, habrá un manejador de eventos que actuará en consecuencia. Si es una tarea automatizada y el loop de ejecución está parado lo pondrá en marcha.
    \item TaskModifiedEvent: si una tarea es modificada se emitirá un evento, habrá un manejador de eventos que actuará en consecuencia. Si la tarea vuelve a ser puesta a pending, es automatizada y el loop de ejecución está parado lo pondrá en marcha
    \item TaskDeletedEvent: si una tarea es modificada se emitirá un evento, habrá un manejador de eventos que actuará en consecuencia.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.4\textheight]{part/memoria_descriptiva/managerDomain}
    \caption[Diagrama de objetos de dominio]{}\label{fig:managerDomain}
\end{figure}



\subparagraph{casos de uso}

Vamos a describir los casos de uso que podrán ejecutarse en el programa manager

\textbf{crear tarea}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.3\textheight]{part/memoria_descriptiva/createTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:createTaskUseCase}
\end{figure}

\textbf{obtener tarea}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.3\textheight]{part/memoria_descriptiva/getTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:getTaskUseCase}
\end{figure}

\textbf{listar tareas}

Uno de los puntos más amplios en una API CRUD es el filtrado de datos. No entra dentro del ámbito de este proyecto crear un sistema de filtrado que incluya la paginación. En este caso habría que crear una nomenclatura de filtros de cara al usuario y un sistema que los procese, devolviendo error ante un filtro erroneo o el listado de tareas que responda a dicho filtro. En nuestro caso devolveremos todas las tareas.

\textbf{actualizar tareas}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.5\textheight]{part/memoria_descriptiva/updateTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:updateTaskUseCase}
\end{figure}

\textbf{eliminar tareas}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.2\textheight]{part/memoria_descriptiva/deleteTaskUseCase}
    \caption[Diagrama de objetos de dominio]{}\label{fig:deleteTaskUseCase}
\end{figure}

\subparagraph{estructura de carpetas}

Una de las partes mas importantes de un proyecto de software es que la estructura de carpetas hable sobre cómo está diseñado el software, sobre de qué va el software. qué es lo que hace y sobre que componentes interactua

\input{./part/memoria_descriptiva/folder_estructure_manager.tex}

Queda pendiente implementar aplicación e infraestructura. Cabe reseñar el apartado de aplicación loop handler. Vamos a detenernos en este concepto de aplicación que si merece la pena mención

\textbf{ejecutar loop de tareas automaticas}

handler que implementará aplicación porque el manual-automatic es muy complejo. al final habrá en este proceso muchos conceptos que descubriremos core de la aplicación y debieran ser dominio, pero como tenemos que descubrirlos vamos a implementarlos en aplicación haciendo uso de interfaces de infraestructura y de elementos de dominio. Si vemos claramente que algo puede convertirse en dominio lo introduciremos.


\paragraph{Client Server}

Hay que tener en cuenta que en este programa será casi todo infrestructura. ya que una vez recepcionado el comando mediante el RPC
solo quedará

En esta memoria descriptiva vamos a diseñar un sistema que tenga palabras clave para diferenciar un comando de pid y otro totalmente distinto. ya que si queremos ejecutar un simple comando de consola en el servidor cliente.

Las posibilidades son tantas como comandos haya instalados en el servidor cliente.

por ejemplo si el comando es ./runMyComand --arg=arg

como un típico comando de consola quedará a cargo del usuario de este progrmaa cliente implementar la interfaz

\paragraph{Control Program}

Casos de uso todas las funciones del engine y diseñarlo para que la infra sea a través de consola de comandos (preparando para que luego debido a la comunicación rpc devolver los datos sea muy complicado si lo dividimos en otro comando y decidimos absorver este dominio)

El sistema está pensado para que el programa a ejecutar sea de libre decisión del cliente. pero vamos a aprovechar la oportunidad para crear un programa de control y profundizar tanto en el uso del lenguaje como en los conocimientos relacionados con este master. En concreto el control automático. Uno do los programas que podrá ejecutar será un control PID.