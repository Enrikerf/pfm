
Se ha diseñado y desarrollado un sistema capaz de gestionar y ejecutar tareas en servidores remotos.
Se ha seguido un proceso que garantiza un grado de calidad y una estructura capaz de enfrentar el cambio iterativo natural en el desarrollo de software.
Cumpliendo con el objetivo principal se ha ejecutado integralmente un ejemplo práctico de aplicación de una metodología que abarca el proceso de desarrollo de software desde su concepción hasta su entrega.
Se ha seguido un diseño estructurado en capas realizando un esfuerzo en crear un lenguaje expresivo en el nombre y la estructura de todos los componentes del software que transmita el problema resuelto, conocido como UL (Ubiquitous Language o Lenguaje Ubicuo).
Este lenguaje concebido facilita la comunicación efectiva del problema que enfrenta el proyecto a todo aquel que necesite interactuar con el sistema.

Uno de los puntos que evidencian la utilidad de los paradigmas utilizados (DDD, Arquitectura Hexagonal y CQRS) es que han facilitado una forma estructurada de enfrentar la construcción de un software en un lenguaje desconocido.
Han enfocado los esfuerzos en aprender lo necesario para implementar los patrones que el diseño demanda.
Convirtiendo el aprendizaje en un proceso ordenado de búsqueda de conceptos necesarios y transversales en todos los lenguajes.

Durante la ejecución se ha podido comprobar que dichos paradigmas han permitido la evolución del diseño hasta su resultado final de forma efectiva, con orden y sin afectar a las bases iniciales.
Se ha enfrentado diversos problemas ante el cambio de los requisitos iniciales.
El ejemplo más claro ha sido la integración del programa de control en el programa cliente.
La fusión o separación de dos programas se vuelve un proceso sencillo cuando la arquitectura es común.
También ha permitido encapsular partes de la tecnología recién aprendida, y por tanto desarrollada con las deficiencias típicas de la primera aproximación, de tal forma que no afecte a la resolución del problema de fondo.
Creando un software entregable que aporta valor acotando sus deficiencias a puntos bien diferenciados.

El presente trabajo ha cumplido ampliamente con el objetivo de evaluar el lenguaje Go como herramienta para un proyecto que enfrente la problemática y metodologías utilizadas.
Se han puesto a prueba los puntos clave que el lenguaje promueve: asincronía y gestión de concurrencia y simplicidad.
Se ha hecho uso tanto en las comunicaciones entre sistemas como en el control efectivo del motor mediante el PID\@.
La simplicidad con la que se consigue abordar el problema, sin requerir gestionar a bajo nivel la dificultad que enfrentan los sistemas en tiempo real ante la concurrencia, es sin duda una característica clave.
Los puntos más reseñables son:

\begin{itemize}
    \item Gestión de los pulsos del encoder: se han hecho pruebas y se consigue no perder ningún pulso del receptor fotoeléctrico.
    La saturación del sistema operativo puede afectar a la capacidad a la interacción del programa de control de con el programa cliente o a cada uno de ellos por separado.
    Dicha saturación pone en riesgo el conteo de pulsos del encoder, punto crítico para el control.
    Con la gestión de la asincronía de Go podemos garantizar que los pulsos son detectados y esperan su turno para ser contabilizados sin perder ninguno.
    \item Comunicación entre todos los sistemas: el sistema desarrollado enfrenta tiempos de latencia naturales en la red y de los bloqueos temporales de cada uno de los sistemas operativos y programas ponen a prueba la gestión eficiente de la interacción.
    El sistema enfrenta la gestión del Manager mandando las consignas, el cliente recibiendo información y devolviendo los resultados que ofrece el programa de control.
    La ejecución de todos los componentes de forma asíncrona y garantizar un buen resultado en un lenguaje sobre el que no se tenía experiencia previa ha sido en buena medida gracias a Go.
\end{itemize}

La arquitectura y el diseño que se han empleado busca que el propio código sea la documentación.
En el desarrollo de software comercial el mantenimiento de la documentación es costoso.
Se ha visto el encaje de adaptar un proyecto de tipo industrial, un estándar definido y bien depurado, para la documentación mínima imprescindible.
Ofrecer un documento con una estructura conocida como forma de introducirse al problema, mantenerse informado del Dominio, comprender el lenguaje propio y entender los casos de uso disponibles para interactuar con el sistema.
%
%La conclusión general es que lo más importante en la gestión de proyectos es estandarizar procesos, tanto de diseño como de documentación.
%De esta forma, cuando los profesionales entran y salen del proyecto sólo requieren aprender el Dominio del problema concreto, no todo el marco del sistema.
%Tal es la motivación y origen de las normas existentes en la industria y la construcción.

\textbf{Evaluación cualitativa del Golang}

Golang nace como un lenguaje enfocado en programas con una envergadura contenida, scripting o microservicios.
Posee una curva de aprendizaje aceptable en relación coste-beneficio para los objetivos que abarcan esta tipología de problemas.
Permite extraer todo el partido a la asincronía, la limpieza y la sencillez.
Tiene paquetes base potentes para abordar un amplio rango de tareas con garantías sin necesitar dependencias externas.

El diseño es un factor importante a la hora de prever la hora de enfrentar el problema inherente al crecimiento de un programa, debido a la adición de funcionalidades.
No siempre está claro para un diseñador el punto en el que conviene separar en diferentes proyectos esas nuevas funcionalidades.
Se puede cometer el error de permitir crecer el programa más allá de lo funcional o el error inverso; separar el programa aumentando la complejidad innecesariamente.
Introducir arquitecturas como la utilizada protege ante esta tipología de errores y permite dividir o reunir el proyecto de forma sencilla cuando se hace evidente que se requiere.

En el proceso de aprendizaje del lenguaje, proveniente de otros lenguajes más maduros, se ha llegado a interpretar como sobre-ingeniería la sintaxis a la que te obliga Go el abordar una estructura lo suficientemente granulada.
Se necesita de estructuras más elaboradas: el equivalente a la clase, el manejo de errores, la no existencia de excepciones y el enfoque de las interfaces, por ejemplo.
Es cierto que brillan por su sencillez y no dejan tanto espacio a la inventiva;
que si bien puede dar lugar a verdaderos ingenios en buenas manos, suele terminar en el desorden y complejidad en el proceso de cambio de manos que sufre un software profesional.
Un ejemplo muy claro es la inexistencia de la herencia, foco de tantos problemas en otros lenguajes.
Los puntos más relevantes de los cuales se ha extraído una conclusión son:

\begin{itemize}
    \item \textbf{Nomenclatura}: la guía de estilo es clara y amplia para dar libertad, pero en Golang se tiende a elegir nombre de variables cortos y poco explicativas.
    Los argumentos se basan en el enfoque a diseños pequeños, modulares, donde la distancia entre la declaración de la variable y su uso no sobrepase una distancia suficiente como para requerir nombres elaborados.
    Está extendido el uso de acrónimos, palabras incompletas y caracteres sueltos.
    Hay otra tendencia a poner más código en un mismo fichero y más ficheros en un mismo directorio que en otros lenguajes.
    Sumando las variables poco explicativas al abundante código en un mismo punto se abre la puerta a un código difícil de leer.
    Poniendo en peligro la cohesión y la limpieza.

    El código que se encuentra en los repositorios de \textit{opensource} más relevantes actualmente recuerda a los comienzos de PHP, Javascript u otros lenguajes de \textit{scripting}.
    Ficheros de muchas lineas, variables incomprensibles, código difícil de leer y muchos ficheros con nombres poco claros en un mismo directorio.
    Es más sencillo renombrar una variable explicativa de más a un nombre corto;
    extraer el significado de una variable nombrada con una letra e intentar darle un nombre mejor no.
    Juntar código en un mismo fichero es más sencillo que separarlo.
    Lo segundo obliga a pensar en su cohesión y sus dependencias.
    Por lo tanto en este proyecto, que además posee un enfoque didáctico, se ha optado por el uso de nombres altamente explicativos.
    Prefiriendo la posibilidad de caer en la redundancia a caer en la falta de claridad.
    También se a optado por dividir cada componente en su propio archivo, algo no normativo en este lenguaje.

    \item \textbf{Interfaces}: en Golang se elimina la palabra reservada \textit{implement} para indicar al compilador que una estructura va a implementar una interfaz.
    El argumento a favor es potente: evitar la necesidad de implementar \textit{wrappers} de librerías de terceros a las que no quieres acoplarte.
    Diseñar una interfaz que cumpla esa librería que quieres utilizar ya te aísla de ella.
    Haciendo uso de la declaración explícita se obliga a desarrollar una clase que implementa nuestra interfaz y hace uso de cada función de la librería;
    es decir un \textit{wrapper}.
    Aumentando la cantidad de código y la complejidad.
    Se opta por evitar el exceso de código burocrático a cambio de ocultar información en la lectura.

    Si la signatura de una función se repite el uso de una misma interfaz es lo más recomendable.
    Sin embargo, en una arquitectura de capas esto ocurre.
    No poder elegir en la implementación de la interfaz del paquete con el que quieres acoplarte aumenta la confusión.

    Donde más se nota esta perdida de claridad es en las interfaces de desarrollo (IDE).
    Las IDEs advierten de qué funciones debe implementar cuando el lenguaje permite indicarlo de forma explícita y facilitan la búsqueda de todas las implementaciones.
    Sin la declaración explicita aparecerán muchas que no tienen, en el fondo, ninguna relación.
    Son perdidas en la limpieza y capacidad de lectura.

    \item \textbf{Equivalente de clases}: Evitar la herencia no parece justificar la eliminación de la declaración de clase.
    Obliga a crear una estructura más compleja: una interfaz que oculte una estructura que implementa las funciones.
    Por otro lado permite devolver \textit{nil} como resultado y no una estructura vacía, lo cual puede dar lugar a inconsistencias.
    Además, Obliga a firmar un contrato de cómo actúa la clase eliminando dependencias por defecto.
    Se puede considerar sobre-ingeniería, pero no añade demasiados inconvenientes a cambio.
    Al final el uso de structs de forma directa da pocas ventajas, Llevando a esta estructura a ser el elemento básico de trabajo en casi cualquier punto.

    \item \textbf{Paquetes y división del código en golang}: En la comunidad se tiende a crear paquetes con muchos archivos, ya que crear directorios para ordenar el código en Golang implica modularizar.
    Cuando se aborda una arquitectura DDD se ha sufrido la complicación de no tener la libertad de crear paquetes según entidades lógicas acotadas.
    Obligando a tener en cuenta la visibilidad y ciclicidad de dependencias.
    El contrapunto es que Golang está pensado para ello, te obliga a seguir un orden estricto.

    \item \textbf{Testing}: El estándar es disponer de los test unitarios al lado de la clase relacionada.
    Esto provoca imports ajenos junto a los ficheros que definen el Dominio.
    El código para crear los dobles en medio de tu código de producción.
    Dificulta la navegación por la estructura de carpetas al tener demasiados archivos ajenos a la estructura del programa.
    La limpieza y la nomenclatura también se aplican a los archivos y organización de ficheros, este estándar lo dificulta.
    Es un punto difícil de aceptar si se procede de otros lenguajes.
\end{itemize}

\textbf{Lineas futuras}

\begin{itemize}
    \item Crear un sistema para que las tareas automáticas se puedan ejecutar en un tiempo requerido y configurado.
    Esto es una tarea básica, pero crear un sistema de temporización parecido al CRONTAB de linux se escapaba del ámbito del proyecto.
    Además el sistema de ejecución automática asíncrona y gestión por eventos deja muy localizada y de fácil acceso esta iteración.
    \item Separación del programa cliente del programa de control.
    Este punto no ha sido logrado por el requerimiento de tiempo.
    Separar el programa cliente del programa a ejecutar facilita la creación de los programas de control sin afectar a las funcionalidades comunes.
    \item Creación de programas de control variados y sintonización del PID que pongan a prueba el sistema.
    Investigar su aplicación para el sector del internet de las cosas.
    Gestión de el automatizado de actuadores en un hogar y su monitorización.
    \item Mejora del hardware, evitar el montaje provisional en proto-board.
    Crear una plataforma hardware para el control de motores de corriente continua en posición y velocidad.
    \item La ejecución manual de las tareas de forma bidireccional cuando los navegadores lo permitan o investigar alternativas.
    \item Implementación del concepto de contexto que ofrece Go para garantizar la seguridad de ejecución de los hilos.
\end{itemize}
