
Golang es un lenguaje enfocado en programas con una envergadura muy acotada o scripting. Es sencillo y con una curva de aprendizaje aceptable para los objetivos básicos que abarcan este tipo de programas. Permitiendo extraer todo el partido a la asincronía, la limpieza y la sencillez. Tiene paquetes base muy potentes que permiten abordar pequeñas tareas con muchas garantías sin necesidad de añadir dependencias de terceros. Pequeños endpoints, scripts de procesamiento, algoritmia, paralelismo. Lo cual lo vuelve un candidato muy viable para lo que se suele utilizar python.

Sin embargo, casi todos los proyectos grandes empiezan siendo pequeños. Los programas que son utilizados evolucionan. Se van añadiendo funcionalidades y terminan necesitando estructura y diseño para soportar dicho crecimiento, que es lo que ha puesto a prueba principalmente este proyecto. Si bien se puede argumentar que esto no debiera ocurrir, que es un error de diseño no modularizar y permitir crecer un proyecto hasta ese punto, la realidad es que estos errores ocurren. Introducir este tipo de arquitecturas protege ante esta tipología de errores y permite dividir el proyecto de forma sencilla cuando se hace evidente que se requiere. No siempre es tan evidente hasta que puede llegar a ser demasiado tarde.

En estos casos, el desarrollador que provenga de otros lenguaje más maduros y con sintaxis más amplias, puede llegar a sentir que Golang tiende a necesitar sobreingeniería al abordar una estructura lo suficientemente granulada. Se necesita de estructuras más elaboradas: el equivalente a la clase, el manejo de errores, la no existencia de excepciones y el enfoque de las interfaces, por ejemplo. Es cierto que brillan por su sencillez y no dejan tanto espacio a la inventiva; que si bien puede dar lugar a verdaderos ingenios en buenas manos, suele terminar en el desorden y complejidad. Un ejemplo muy claro es la inexistencia de la herencia, foco de tantos problemas en otros lenguajes.

\textbf{Nomenclatura}

Es cierto que la guia de estilo tiene una filosofía muy bien enfocada y lo suficientemente amplia como para dar libertad. Sin embargo, lo que se aprecia en la comunidad es que, precisamente por ese enfoque a scripting, se tiende a elegir variables muy cortas, poco explicativas. Tienen sus argumentos para justificarlo: realizar diseños pequeños, muy modulares, donde la distancia entre la declaración de la variable y su uso no sobrepase una distancia suficiente como para necesitar nombres elaborados. Esto choca de lleno, con la tendencia de abusar a poner mucho código en un mismo fichero y evitar la división. Si sumamos el nombrado de variables que abusan de acrónimos, palabras incompletas y caracteres sueltos, a abundante código en un mismo fichero se abre la puerta a un código dificil de leer. Se pierde de vista la cohesión.

A pesar de los argumentos favorables a la nomenclatura que proponen, no deja de recordar a los comienzos de php, javascript o demás lenguajes de scripting. Es ampliamente conocido cómo acaban estas tendencias: ficheros de muchas lineas, variables imcomprensibles y código difícil de leer. Refactorizar un nombre largo y explicativo a uno corto siempre será mucho más sencillo que extraer el significado de una variable nombrada con una letra e intentar darle un nombre mejor. Siempre será más fácil juntar código en un mismo fichero que separarlo. Lo segundo obliga a pensar en su cohesión y sus dependencias.

Por lo tanto en este proyecto, que además pretendía ser didáctico, se ha optado por el uso de nombres altamente explicativos. Sin temor a caer en la redundancia, el abuso. También se a optado por dividir cada componente en su propio archivo, algo nada normativo en este lenguaje.

\textbf{Interfaces}

La teoría apoya la decisión de eliminar la palabra reservada \textit{implement} indicando al compilador que una estructura va a implementar una interfaz. El argumento a favor más potente que tiene Golang es evitar la necesidad de implementar \textit{wrappers} de librerias de terceros a las que no quieres acoplarte. Diseñar una interfaz que cumpla esa librería que quieres utilizar ya te aisla de ella. De no ser así, al ser de terceros, habría de modificar la librería e implementarla explicitamente; lo cual es absurdo. Por lo que se desarrolla una clase que implemententa nuestra interfaz y hace uso de cada función de la librería; es decir un \textit{wrapper}. Lo cual aumenta la cantidad de código y la complejidad.

También cierto que si la signatura de una función se repite debiera ser la misma interfaz y no escribir dos veces la misma. Sin embargo, en una arquitectura de capas esto ocurre; ya sea por mal diseño o por que es inevitable en algunos casos. No poder elegir en la implementación de la interfaz con qué paquete está dicho acoplamiento provoca que pueda ser confuso. las interfaces de desarrolo, IDEs, suelen ayudarte y advertirte de qué funciones debe implementar. Además de que si buscas cuántas funciones implementan tu interfaz aparecerán muchas que no tienen, en el fondo, ninguna relación. Son perdidas en la limpieza y capacidad de lectura.

No suele provocar tanto tempor el exceso de código burocrático, como son los wrappers, como a la dificultad de lectura o falta de orden. No disponer de la declaración explícita de la interfaz favorece el desorden. No siendo un punto crítico, es sin embargo la característica que menos amigable de Golang con respecto a la sintáxis.

\textbf{Equivalente de clases}

Es un punto que incomoda y desconcierta al principio. Que se quiera evitar la herencia no parece justificar de la palabra reservada para crear una clase. Tener que crear más código a través de la creación de una interfaz que oculte la estructura implementada se antoja innecesario. Una vez aceptado es cierto que es quizá lo más cómodo de Golang. Poder devolver \textit{nil} como resultado y no una estructura vacía, lo cual puede ser peligroso, casa muy bien con su forma de manejar errores. Además de que obligar a firmar un contrato de cómo actua la clase ayuda a modularizar por defecto. Se puede considerar sobreingeniería, pero no añade demasiados inconvenientes a cambio. Mi conclusión es que no utilizaría structs sueltos en casi ningún punto. A lo mejor muy encapsulados en una función que enfrente una algoritmia complicada y requiera estructurar datos de una forma rápida de una forma totalmente aislada del exterior.

\textbf{Paquetes y división del código en golang}

En la comunidad se tiende a crear paquetes con muchos archivos, ya que crear directorios para ordenar el código en Golang implica modularizar. Se echa en falta alguna herramienta para ordenar el código a nivel estructura de carpetas sin afectar al desarrollo; poder escoger y acotar la visibilidad de los elementos públicos dentro de un submodulo. Cuando se aborda una arquitectura DDD se puede llegar a complicar al no tener la libertad de paquetizar según entidades lógicas acotadas. Obligando a tener en cuenta la visibilidad y ciclicidad de dependencias. El contrapunto es que Golang está pensado para ello, te obliga a seguir el orden establecido.

\textbf{Testing}

El estandar es disponer de los test unitarios al lado de la clase relacionada. Esto provoca imports ajenos en el dominio. El codigo para crear los dobles en medio de tu codigo de producción. Dificulta la navegación por la estructura de carpetas al tener demasiados archivos ajenos a la estructura del programa. La limpieza y el naming también se aplican a los archivos y organización de ficheros, este estándar lo dificulta. Puede venir bien para gestión de equipos que vengan de scripting porque sentirán mayor orden, pero me aventuro a asegurar que es un punto difícil de aceptar para casi todos los profesionales que vengan de otros lenguajes.

\textbf{Gestión del proyecto}

La arquitectura y el diseño que se han empleado busca que el propio código sea la documentación. Un entregable es requisito imprecintible para un tfm, pero en la profesión, el mantenimiento de esta documentación se vuelve muchas veces algo extremadamente costoso de mantener. Sin embargo, existe un un minimo de documentación imprescindible para los profesionales no técnicos que intervienen en el proyecto, ahí es donde se ha visto el encaje de adaptar un proyecto de tipo industrial. Ofrecer una forma de introducirse y mantenerse informado del UL y entender los casos de uso disponibles para interactuar con el sistema.

Hay mucha teoría al respecto de la gestión de proyectos y documentación del software, pero se ha querido explorar la opción de partir de un estándar ya definido y bien depurado como es la presentacion de proyectos de carácter industrial. La conclusión es que lo más importante en la gestión es estandarizar procesos. De esta forma, cuando los profesionales entran y salgen de proyectos sólo requieren aprender el proyecto en sí, no todo el sistema de gestión. Determinar una estructura estándar de documentación y entrega es el motivo de las normas existentes en la industria y la construcción. Son fruto y razón por la que se ha llegado hasta dónde se encuentran el día de hoy. Un proceso de aprendizaje de cientos de años para la construcción y la industria. El desarrollo de software, ya sea con las mismas normas o distintas habrá de llegar a ese punto.


\begin{itemize}
    \item crear un sistema para que las tareas automaticas se puedan ejecutar en un tiempo requerido y configurado. Esto es una tarea básica, pero crear un sistema de temporización parecido al CRONTAB de linux se escapaba del ámbito del proyecto. Además el sistema de ejecución automática asíncrona y gestión por eventos deja muy localizada y de fácil acceso esta iteración.
    \item la ejecución manual de las tareas de forma bidireccional cuando los navegadores lo permitan o investigar alternativas
    \item separación del programa cliente del programa de control
    \item creación de programas de control variados que pongan a prueba el sistema
    \item test de flujo de carga
    \item mejora del hardware, evitar el motaje provisional en protoboard
    \item implementar el concepto de context nativo de golang para el control de timeouts de las gorutines.
\end{itemize}
